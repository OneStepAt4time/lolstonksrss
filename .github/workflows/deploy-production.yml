name: Deploy to Production (Windows Server)

on:
  push:
    branches:
      - main
      - master
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      skip_healthcheck:
        description: 'Skip health checks (not recommended)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  CONTAINER_NAME: lolstonksrss
  DEPLOY_TIMEOUT: 600

permissions:
  contents: read
  packages: write

jobs:
  # Pre-deployment checks
  pre-deploy:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      image_tag: ${{ steps.meta.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=prod-

      - name: Verify CI checks passed
        id: check
        run: |
          echo "Checking repository status..."
          echo "Image tag: ${{ steps.meta.outputs.version }}"
          echo "Should deploy: true"
          echo "should_deploy=true" >> $GITHUB_OUTPUT

  # Build and push Docker image
  build:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: pre-deploy
    if: needs.pre-deploy.outputs.should_deploy == 'true'
    outputs:
      tags: ${{ steps.meta.outputs.tags }}
      version: ${{ steps.meta.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha,prefix=prod-
            type=raw,value=latest

      - name: Build and push Docker image
        id: push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Generate artifact attestation
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

  # Deploy to Windows Server
  deploy:
    name: Deploy to Windows Server
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: production
      url: https://${{ secrets.WINDOWS_SERVER_HOST }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.WINDOWS_SERVER_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.WINDOWS_SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Verify SSH connection
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 \
            ${{ secrets.WINDOWS_SERVER_USER }}@${{ secrets.WINDOWS_SERVER_HOST }} \
            "echo 'SSH connection successful' && docker --version && docker-compose --version"

      - name: Pre-deployment backup
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.WINDOWS_SERVER_USER }}@${{ secrets.WINDOWS_SERVER_HOST }} \
            "cd ${{ secrets.WINDOWS_SERVER_DEPLOY_PATH }} && \
             if (docker images -q ${{ env.CONTAINER_NAME }}:latest) { \
               docker tag ${{ env.CONTAINER_NAME }}:latest ${{ env.CONTAINER_NAME }}:previous; \
               echo 'Previous version backed up'; \
             } else { \
               echo 'No previous version to backup'; \
             }"

      - name: Pull new Docker image
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.WINDOWS_SERVER_USER }}@${{ secrets.WINDOWS_SERVER_HOST }} \
            "echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin && \
             docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest && \
             docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest ${{ env.CONTAINER_NAME }}:latest"

      - name: Stop existing container
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.WINDOWS_SERVER_USER }}@${{ secrets.WINDOWS_SERVER_HOST }} \
            "cd ${{ secrets.WINDOWS_SERVER_DEPLOY_PATH }} && \
             if (docker ps -q -f name=${{ env.CONTAINER_NAME }}) { \
               docker stop ${{ env.CONTAINER_NAME }} && docker rm ${{ env.CONTAINER_NAME }}; \
               echo 'Stopped and removed existing container'; \
             } else { \
               echo 'No existing container to stop'; \
             }"

      - name: Start new container
        run: |
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.WINDOWS_SERVER_USER }}@${{ secrets.WINDOWS_SERVER_HOST }} \
            "cd ${{ secrets.WINDOWS_SERVER_DEPLOY_PATH }} && \
             docker run -d \
               --name ${{ env.CONTAINER_NAME }} \
               --restart unless-stopped \
               -p 8000:8000 \
               -v ./data:/app/data \
               -e DATABASE_PATH=/app/data/articles.db \
               -e HOST=0.0.0.0 \
               -e PORT=8000 \
               -e LOG_LEVEL=INFO \
               -e BASE_URL=http://${{ secrets.WINDOWS_SERVER_HOST }}:8000 \
               -e SUPPORTED_LOCALES=en-us,it-it \
               --label 'deployed_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")' \
               --label 'deployed_by=${{ github.actor }}' \
               --label 'git_sha=${{ github.sha }}' \
               ${{ env.CONTAINER_NAME }}:latest && \
             echo 'Container started'"

      - name: Wait for container startup
        run: |
          echo "Waiting for container to initialize..."
          sleep 45

      - name: Health check
        id: healthcheck
        run: |
          MAX_ATTEMPTS=30
          ATTEMPT=0
          HEALTH_URL="http://${{ secrets.WINDOWS_SERVER_HOST }}:8000/health"

          echo "Checking health endpoint: $HEALTH_URL"

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Health check attempt $ATTEMPT/$MAX_ATTEMPTS"

            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 $HEALTH_URL || echo "000")

            if [ "$HTTP_STATUS" = "200" ]; then
              HEALTH_RESPONSE=$(curl -s --max-time 10 $HEALTH_URL)
              HEALTH_STATUS=$(echo $HEALTH_RESPONSE | grep -o '"status":"[^"]*"' | cut -d':' -f2 | tr -d '"')

              if [ "$HEALTH_STATUS" = "healthy" ]; then
                echo "Health check passed!"
                echo "health_status=healthy" >> $GITHUB_OUTPUT
                exit 0
              fi
            fi

            echo "Health check failed (status: $HTTP_STATUS), retrying in 5 seconds..."
            sleep 5
          done

          echo "health_status=unhealthy" >> $GITHUB_OUTPUT
          echo "Health check failed after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Verify feed endpoints
        if: steps.healthcheck.outputs.health_status == 'healthy'
        run: |
          echo "Verifying feed endpoints..."

          # Check main feed
          curl -f -s -o /dev/null --max-time 10 \
            "http://${{ secrets.WINDOWS_SERVER_HOST }}:8000/feed.xml" || {
            echo "Main feed check failed"
            exit 1
          }
          echo "Main feed OK"

          # Check English feed
          curl -f -s -o /dev/null --max-time 10 \
            "http://${{ secrets.WINDOWS_SERVER_HOST }}:8000/feeds/en-us.xml" || {
            echo "English feed check failed"
            exit 1
          }
          echo "English feed OK"

          # Check Italian feed
          curl -f -s -o /dev/null --max-time 10 \
            "http://${{ secrets.WINDOWS_SERVER_HOST }}:8000/feeds/it-it.xml" || {
            echo "Italian feed check failed"
            exit 1
          }
          echo "Italian feed OK"

          echo "All feed endpoints verified"

      - name: Deployment successful
        if: success()
        run: |
          echo "=== Deployment Summary ==="
          echo "Environment: production"
          echo "Server: ${{ secrets.WINDOWS_SERVER_HOST }}"
          echo "Image: ${{ needs.build.outputs.tags }}"
          echo "Version: ${{ needs.build.outputs.version }}"
          echo "Deployed by: ${{ github.actor }}"
          echo "Git SHA: ${{ github.sha }}"
          echo ""
          echo "Deployment completed successfully!"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed. Initiating rollback..."

          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.WINDOWS_SERVER_USER }}@${{ secrets.WINDOWS_SERVER_HOST }} \
            "cd ${{ secrets.WINDOWS_SERVER_DEPLOY_PATH }} && \
             echo 'Stopping failed container...' && \
             docker stop ${{ env.CONTAINER_NAME }} 2>/dev/null || true && \
             docker rm ${{ env.CONTAINER_NAME }} 2>/dev/null || true && \
             \
             if (docker images -q ${{ env.CONTAINER_NAME }}:previous) { \
               echo 'Rolling back to previous version...' && \
               docker tag ${{ env.CONTAINER_NAME }}:previous ${{ env.CONTAINER_NAME }}:latest && \
               \
               docker run -d \
                 --name ${{ env.CONTAINER_NAME }} \
                 --restart unless-stopped \
                 -p 8000:8000 \
                 -v ./data:/app/data \
                 -e DATABASE_PATH=/app/data/articles.db \
                 -e HOST=0.0.0.0 \
                 -e PORT=8000 \
                 -e LOG_LEVEL=INFO \
                 -e BASE_URL=http://${{ secrets.WINDOWS_SERVER_HOST }}:8000 \
                 ${{ env.CONTAINER_NAME }}:latest && \
               \
               echo 'Waiting for rollback to initialize...' && \
               sleep 45 && \
               \
               echo 'Rollback completed' && \
               exit 0; \
             } else { \
               echo 'No previous version found for rollback!' && \
               exit 1; \
             fi"

      - name: Verify rollback
        if: failure() && steps.healthcheck.outcome == 'failure'
        run: |
          echo "Verifying rollback health..."
          MAX_ATTEMPTS=20
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Rollback health check attempt $ATTEMPT/$MAX_ATTEMPTS"

            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 \
              "http://${{ secrets.WINDOWS_SERVER_HOST }}:8000/health" || echo "000")

            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Rollback verification successful!"
              exit 0
            fi

            sleep 5
          done

          echo "Rollback verification failed!"
          exit 1

      - name: Notify on rollback
        if: failure()
        run: |
          echo "=== ROLLBACK NOTIFICATION ==="
          echo "Deployment to production failed and was rolled back."
          echo "Please investigate the issue."
          echo ""
          echo "Server: ${{ secrets.WINDOWS_SERVER_HOST }}"
          echo "Failed version: ${{ needs.build.outputs.version }}"
          echo "Deployed by: ${{ github.actor }}"
          echo ""
          echo "Check server logs:"
          echo "  ssh ${{ secrets.WINDOWS_SERVER_USER }}@${{ secrets.WINDOWS_SERVER_HOST }}"
          echo "  docker logs ${{ env.CONTAINER_NAME }}"
          echo ""
          echo "Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key

  # Post-deployment notification
  notify:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [build, deploy]
    if: always()
    steps:
      - name: Deployment status
        run: |
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "STATUS=success" >> $GITHUB_ENV
            echo "Production deployment SUCCESSFUL"
            echo ""
            echo "Version: ${{ needs.build.outputs.version }}"
            echo "Deployed by: ${{ github.actor }}"
          else
            echo "STATUS=failure" >> $GITHUB_ENV
            echo "Production deployment FAILED"
            echo ""
            echo "Version: ${{ needs.build.outputs.version }}"
            echo "Deployed by: ${{ github.actor }}"
            echo ""
            echo "Please investigate the deployment logs."
            exit 1
          fi
